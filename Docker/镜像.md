# 创建
## 交互式创建
简单说就是在已有的镜像的基础上，再次修改和提交。

以 `alpine` 为例：
运行容器：
> docker run -it --name sample alpine /bin/sh

增加新包，支持 `ping` 等操作：
> / # apk update && apk add iputils

此时就可以使用 `ping` 等程序：
> / # ping 127.0.0.1

定制修改完后，退出容器：
> / # exit

查看容器的差异：
> docker diff sample

列表中， `C` 表示的改变的文件， `A` 表示的是新增的文件， `D` 表示的是删除的文件。

提交修改，生成新的镜像：
> docker commit sample my-alpine

查看镜像列表：
> docker images

查看 `my-alpine` 镜像的提交历史：
> docker image hisotry my-alpine

## Dockerfile
以 `Dockerfile` 作为清单，用来创建镜像。`Dockerfile` 是一系列命令组合而成的一个文件。每一个命令都会在其基础层上创建一个新的层。例如：
```
FROM python:2.7
RUN mkdir -p /app
WORKDIR /app
COPY ./requirements.txt /app/
RUN pip install -r requirements.txt
CMD ["python", "main.py"]
```

其层结构为：

![layer](./resources/docker-layer.PNG)


- FROM: 镜像的基础镜像层。一个特例就是：
    ```
    FROM scratch
    ```

    以 `scratch` 作为基础层实际上不会在镜像中新增一个层。

- RUN: 运行任意的合法的 Linux 命令。
- COPY 和 ADD: 都是用来往镜像层中增加数据。区别就是 ADD 一个压缩包的话，会被解压；同时源文件可以是 URL。
- WORKDIR: 定义工作目录或者上下文。
- CMD 和 ENTRYPOINT: 这两个命令用来指明镜像在运行期的行为。可就是告诉 Docker 当容器起来时，执行哪个进程以及如何执行。它们的区别是 ENTRYPOINT 定义运行的程序；而 CMD 则定义程序的运行参数。 CMD 中也可以执行程序而不依赖 ENTRYPOINT 。同时， CMD 参数可以在容器启动时被覆盖， ENTRYPOINT 也可以使用 --entrypoint 来覆盖。
    ```
    FROM alpine:latest
    ENTRYPOINT ["ping"]
    CMD ["8.8.8.8", "-c", "3"]
    ```
    在只有 CMD 的情况下，将会使用默认的  /bin/sh -c ，比如：
    ```
    FROM alpine:latest
    CMD wget -O - http://www.google.com
    ```
    在容器内部其实是这样执行的：
    > /bin/sh -c "wget -O - http://www.google.com"

镜像创建的整个过程：

![image-build](./resources/image-build-process.PNG)

### 多阶段构建
参照 `multiStepBuilds`

### 最佳实践
- 首先，得认为容器声明周期是短暂的。因为生命期短暂，所以在容器的启动、停止和销毁的配置时间就需要短，间接地，容器内运行的程序的初始化和终止的时间就需要尽可能的短。
- 应该讲各个命令进行特定的排序，尽可能利用缓存

## 压缩包
从 `tarball` 中导入，根据导入到系统的内容创建。
